sudo apt-get install mysql-server mysql-client 

mysql --user=root --password mysql

create user 'java'@'%' identified by 'school';

grant all privileges on *.* to 'java'@'%';



한글이 안되는 이유

mysql --user=root --password mysql

mysql> status
--------------
mysql  Ver 14.14 Distrib 5.6.24, for debian-linux-gnu (x86_64) using  EditLine wrapper

Connection id:		3
Current database:	mysql
Current user:		root@localhost
SSL:			Not in use
Current pager:		stdout
Using outfile:		''
Using delimiter:	;
Server version:		5.6.24-0ubuntu2 (Ubuntu)
Protocol version:	10
Connection:		Localhost via UNIX socket
Server characterset:	latin1
Db     characterset:	latin1
Client characterset:	utf8
Conn.  characterset:	utf8
UNIX socket:		/var/run/mysqld/mysqld.sock
Uptime:			20 min 12 sec

Threads: 1  Questions: 124  Slow queries: 0  Opens: 93  Flush tables: 1  Open tables: 83  Queries per second avg: 0.102
--------------

https://fosskb.wordpress.com/2015/04/18/installing-openstack-kilo-on-ubuntu-15-04-single-machine-setup/

Edit the following lines in /etc/mysql/my.cnf (/etc/mysql/mysql.conf.d/mysqld.cnf in 15.04)

bind-address = 0.0.0.0
[mysqld]
...
default-storage-engine = innodb
innodb_file_per_table
collation-server = utf8_general_ci
init-connect = 'SET NAMES utf8'
character-set-server = utf8

Restart MySQL service
service mysql restart


mysql> status
--------------
mysql  Ver 14.14 Distrib 5.6.24, for debian-linux-gnu (x86_64) using  EditLine wrapper

Connection id:		2
Current database:	mysql
Current user:		root@localhost
SSL:			Not in use
Current pager:		stdout
Using outfile:		''
Using delimiter:	;
Server version:		5.6.24-0ubuntu2 (Ubuntu)
Protocol version:	10
Connection:		Localhost via UNIX socket
Server characterset:	utf8
Db     characterset:	utf8
Client characterset:	utf8
Conn.  characterset:	utf8
UNIX socket:		/var/run/mysqld/mysqld.sock
Uptime:			12 sec

Threads: 1  Questions: 35  Slow queries: 0  Opens: 87  Flush tables: 1  Open tables: 80  Queries per second avg: 2.916

jdbc 드라이버 복사
sudo cp mysql-connector-java-5.1.36-bin.jar /usr/share/tomcat7/lib/


security.xml

  <authentication-manager>
    <authentication-provider>
      <jdbc-user-service
        data-source-ref="dataSource"
        users-by-username-query="select email as username,passwd as password,1 as enabled
        from member where email = ?"
        authorities-by-username-query="select email as username,authority
        from authorities where email = ?" />
    </authentication-provider>
  </authentication-manager>


applicationContext.xml

  <bean id="dataSource" class="org.apache.commons.dbcp.BasicDataSource" destroy-method="close">
    <property name="driverClassName" value="com.mysql.jdbc.Driver"/>
    <property name="url" value="jdbc:mysql://localhost:3306/javaschool?useUnicode=yes&amp;characterEncoding=UTF-8" />
    <property name="username" value="java"/>
    <property name="password" value="school"/>
    <property name="maxActive" value="100"/>
    <property name="maxWait" value="1000"/>
    <property name="poolPreparedStatements" value="true"/>
    <property name="defaultAutoCommit" value="true"/>
    <property name="validationQuery" value=" SELECT 1" />
  </bean>


mysql은 테이블명이 대소문자를 가리니 조심한다.
userMapper.xml에는 고칠것이 대문자 테이블명 뿐

pom.xml
  <artifactId>spring-bbs-mysql</artifactId>

  <build>
    <finalName>spring-bbs-mysql</finalName>
      <pluginManagement>
        <plugins>
          <plugin>
            <artifactId>maven-compiler-plugin</artifactId>
            <version>3.1</version>
            <configuration>
              <source>${jdk.version}</source>
              <target>${jdk.version}</target>
              <compilerArgument></compilerArgument>
              <encoding>UTF-8</encoding>
            </configuration>
          </plugin>
        </plugins>
      </pluginManagement>
   </build>


springBbsMysql.xml
<?xml version="1.0" encoding="UTF-8"?>
<Context
    docBase="/home/kim/Lab/maven/SpringBbsMysql/src/main/webapp"
    reloadable="true">
</Context>

한글설정을 마무리하고 데이터베이스를 생성한다.

create database javaschool;

mysql --user=java --password javaschool
show tables;
테이블 없는 거 확인하고
source /home/kim/mysql-database-schema.sql


The problem may be caused by specifying utf8 and not UTF-8. From Using Character Sets and Unicode:

When specifying character encodings on the client side, use Java-style names. The following table lists MySQL character set names and the corresponding Java-style names...

and utf8 maps to UTF-8. Try the following JDBC URL:

jdbc:mysql://localhost:3306/?useUnicode=yes&characterEncoding=UTF-8

목록 쿼리
OUTER JOIN
OUTER JOIN은 조인하는 테이블의 ON 절의 조건 중 한쪽의 데이터를 모두 가져옵니다.

OUTER JOIN은 LEFT OUTER JOIN, RIGHT OUTER JOIN, FULL OUTER JOIN 이렇게 3가지가 있습니다.

LEFT OUTER JOIN을 거의 대부분 사용하여, FULL OUTER JOIN은 성능상 거의 사용하지 않습니다.

SELECT *
FROM A_TABLE AS A LEFT OUTER JOIN B_TABLE AS B    -- A_TABLE 기준
ON A_TABLE.COL1 = B_TABLE.COL1

-- A_TABLE.COL1이 존재하지만 B_TABLE.COL1이 존재하지 않으면 B_TABLE.COL1은 NULL로 출력됩니다.
8.2.1.10 Outer Join Simplification

Table expressions in the FROM clause of a query are simplified in many cases.

At the parser stage, queries with right outer joins operations are converted to equivalent queries containing only left join operations. In the general case, the conversion is performed according to the following rule:

(T1, ...) RIGHT JOIN (T2,...) ON P(T1,...,T2,...) =
(T2, ...) LEFT JOIN (T1,...) ON P(T1,...,T2,...)

All inner join expressions of the form T1 INNER JOIN T2 ON P(T1,T2) are replaced by the list T1,T2, P(T1,T2) being joined as a conjunct to the WHERE condition (or to the join condition of the embedding join, if there is any).

When the optimizer evaluates plans for join queries with outer join operation, it takes into consideration only the plans where, for each such operation, the outer tables are accessed before the inner tables. The optimizer options are limited because only such plans enables us to execute queries with outer joins operations by the nested loop schema.

Suppose that we have a query of the form:

SELECT * T1 LEFT JOIN T2 ON P1(T1,T2)
  WHERE P(T1,T2) AND R(T2)

with R(T2) narrowing greatly the number of matching rows from table T2. If we executed the query as it is, the optimizer would have no other choice besides to access table T1 before table T2 that may lead to a very inefficient execution plan.

Fortunately, MySQL converts such a query into a query without an outer join operation if the WHERE condition is null-rejected. A condition is called null-rejected for an outer join operation if it evaluates to FALSE or to UNKNOWN for any NULL-complemented row built for the operation.

Thus, for this outer join:

T1 LEFT JOIN T2 ON T1.A=T2.A

Conditions such as these are null-rejected:

T2.B IS NOT NULL,
T2.B > 3,
T2.C <= T1.C,
T2.B < 2 OR T2.C > 1

Conditions such as these are not null-rejected:

T2.B IS NULL,
T1.B < 3 OR T2.B IS NOT NULL,
T1.B < 3 OR T2.B > 3

The general rules for checking whether a condition is null-rejected for an outer join operation are simple. A condition is null-rejected in the following cases:

    If it is of the form A IS NOT NULL, where A is an attribute of any of the inner tables

    If it is a predicate containing a reference to an inner table that evaluates to UNKNOWN when one of its arguments is NULL

    If it is a conjunction containing a null-rejected condition as a conjunct

    If it is a disjunction of null-rejected conditions 

A condition can be null-rejected for one outer join operation in a query and not null-rejected for another. In the query:

SELECT * FROM T1 LEFT JOIN T2 ON T2.A=T1.A
                 LEFT JOIN T3 ON T3.B=T1.B
  WHERE T3.C > 0

the WHERE condition is null-rejected for the second outer join operation but is not null-rejected for the first one.

If the WHERE condition is null-rejected for an outer join operation in a query, the outer join operation is replaced by an inner join operation.

For example, the preceding query is replaced with the query:

SELECT * FROM T1 LEFT JOIN T2 ON T2.A=T1.A
                 INNER JOIN T3 ON T3.B=T1.B
  WHERE T3.C > 0

For the original query, the optimizer would evaluate plans compatible with only one access order T1,T2,T3. For the replacing query, it additionally considers the access sequence T3,T1,T2.

A conversion of one outer join operation may trigger a conversion of another. Thus, the query:

SELECT * FROM T1 LEFT JOIN T2 ON T2.A=T1.A
                 LEFT JOIN T3 ON T3.B=T2.B
  WHERE T3.C > 0

will be first converted to the query:

SELECT * FROM T1 LEFT JOIN T2 ON T2.A=T1.A
                 INNER JOIN T3 ON T3.B=T2.B
  WHERE T3.C > 0

which is equivalent to the query:

SELECT * FROM (T1 LEFT JOIN T2 ON T2.A=T1.A), T3
  WHERE T3.C > 0 AND T3.B=T2.B

Now the remaining outer join operation can be replaced by an inner join, too, because the condition T3.B=T2.B is null-rejected and we get a query without outer joins at all:

SELECT * FROM (T1 INNER JOIN T2 ON T2.A=T1.A), T3
  WHERE T3.C > 0 AND T3.B=T2.B

Sometimes we succeed in replacing an embedded outer join operation, but cannot convert the embedding outer join. The following query:

SELECT * FROM T1 LEFT JOIN
              (T2 LEFT JOIN T3 ON T3.B=T2.B)
              ON T2.A=T1.A
  WHERE T3.C > 0

is converted to:

SELECT * FROM T1 LEFT JOIN
              (T2 INNER JOIN T3 ON T3.B=T2.B)
              ON T2.A=T1.A
  WHERE T3.C > 0,

That can be rewritten only to the form still containing the embedding outer join operation:

SELECT * FROM T1 LEFT JOIN
              (T2,T3)
              ON (T2.A=T1.A AND T3.B=T2.B)
  WHERE T3.C > 0.

When trying to convert an embedded outer join operation in a query, we must take into account the join condition for the embedding outer join together with the WHERE condition. In the query:

SELECT * FROM T1 LEFT JOIN
              (T2 LEFT JOIN T3 ON T3.B=T2.B)
              ON T2.A=T1.A AND T3.C=T1.C
  WHERE T3.D > 0 OR T1.D > 0

the WHERE condition is not null-rejected for the embedded outer join, but the join condition of the embedding outer join T2.A=T1.A AND T3.C=T1.C is null-rejected. So the query can be converted to:

SELECT * FROM T1 LEFT JOIN
              (T2, T3)
              ON T2.A=T1.A AND T3.C=T1.C AND T3.B=T2.B
  WHERE T3.D > 0 OR T1.D > 0

The algorithm that converts outer join operations into inner joins was implemented in full measure, as it has been described here, in MySQL 5.0.1. MySQL 4.1 performs only some simple conversions. 


다중 left 조인 예
SELECT Dog.Name, COALESCE(SUM(Bite.times_bitten), 0) AS times_bitten
FROM Dog
LEFT JOIN Flea
  ON Flea.Dog_id = Dog.id
    AND Flea.color = "Brown"
LEFT JOIN Bite
  ON Bite.id = Flea.Bite_id
GROUP BY Dog.Name

초안
SELECT 
	a.articleno, a.title, a.regdate, a.hit, m.name, 
	count(distinct(f.attachfileno)) attachfileNum, 
	count(distinct(c.commentno)) commentNum
FROM 
	article as a left join attachfile as f on a.articleno = f.articleno
		left join comments as c on a.articleno = c.articleno
		left join member as m on a.email = m.email
WHERE
	a.boardcd = 'free'
GROUP BY a.articleno, title, a.regdate, hit, m.name
ORDER BY articleno DESC

Difference between NOW(), SYSDATE() & CURRENT_DATE() in MySQL
http://stackoverflow.com/questions/24137752/difference-between-now-sysdate-current-date-in-mysql

[MySQL] DB 쿼리결과 개수 제한하기 - Limit 연산자

Limit 연산자를 이용하면 쿼리 결과 개수를 제한할 수 있다.

?
1
	
select * from 테이블명 Limit 개수(정수);



예) cookie_sales 테이블에서 first_name별로 그룹을 만들어 sales컬럼의 합계가 가장 높은 순으로 
     출력하되, 2개까지만 출력한다.

?
1
2
3
4
	
select first_name, sum(sales) from cookie_sales
group by first_name
order by sum(sales) desc
Limit 2;

결과
 first_name 	sales 
 Britney 	107.91 
 Paris 	98.23 




Limit의 조금 다른 사용법

아래처럼 두 개의 정수가 들어간다면 완전히 다른 의미가 된다. 

Limit 0, 4 
                  0은 시작할 레코드의 번호이다. (SQL은 0이 처음)
                  4는 반환할 결과의 수이다. 


예를 들어 음악 챠트에서 20위에서 30위까지 보고 싶다고 하면
Limit 19,10 으로 하면 된다~


mysql NVL에 해당하는 함수?
ifNull


SELECT       
	a.articleno, a.title, a.regdate, a.hit, m.name,
       count(distinct(f.attachfileno)) attachfileNum,
       count(distinct(c.commentno)) commentNum
FROM       
	article as a left join attachfile as f on a.articleno = f.articleno	
	left join comments as c on a.articleno = c.articleno       
	left join member as m on a.email = m.email     
WHERE      
	a.boardcd = 'free'            
GROUP BY a.articleno, title, a.regdate, hit, m.name     
ORDER BY articleno DESC     
LIMIT '0', '10'

### Cause: com.mysql.jdbc.exceptions.jdbc4.MySQLSyntaxErrorException: 
You have an error in your SQL syntax; 
check the manual that corresponds to your MySQL server version for the right syntax to use near ''0','10'' at line 14

최종 테스트에서
시간 분 초 가 모두 00
 DATE_FORMAT(date,format) : 날짜를 해당 형식의 문자열로 변환하여 반환한다.
- 예 : select DATE_FORMAT('1997-10-04 22:23:00', '%W %M %Y');
select DATE_FORMAT('1997-10-04 22:23:00', '%H:%i:%s');
select DATE_FORMAT('1997-10-04 22:23:00', '%D %y %a %d %m %b %j');
select DATE_FORMAT('1997-10-04 22:23:00', '%H %k %I %r %T %S %w');
- 참고 : 형식은 다음과 같다. %M (달 이름), %W (요일 이름), 
%Y (YYYY 형식의 년도)
%d (DD 형식의 날짜)
%H (HH 형식의 시간, 24시간 형식)
%i (MM 형식의 분)


select date_format(regdate,'%Y/%M/%d %H:%i:%s') from article;

, %y (YY 형식의 년도), %a (요일 이름의 약자), 


11.3.1 The DATE, DATETIME, and TIMESTAMP Types

The DATE, DATETIME, and TIMESTAMP types are related. This section describes their characteristics, how they are similar, and how they differ. MySQL recognizes DATE, DATETIME, and TIMESTAMP values in several formats, described in Section 9.1.3, “Date and Time Literals”. For the DATE and DATETIME range descriptions, “supported” means that although earlier values might work, there is no guarantee.

The DATE type is used for values with a date part but no time part. MySQL retrieves and displays DATE values in 'YYYY-MM-DD' format. The supported range is '1000-01-01' to '9999-12-31'.

The DATETIME type is used for values that contain both date and time parts. MySQL retrieves and displays DATETIME values in 'YYYY-MM-DD HH:MM:SS' format. The supported range is '1000-01-01 00:00:00' to '9999-12-31 23:59:59'.

The TIMESTAMP data type is used for values that contain both date and time parts. TIMESTAMP has a range of '1970-01-01 00:00:01' UTC to '2038-01-19 03:14:07' UTC.

MySQL converts TIMESTAMP values from the current time zone to UTC for storage, and back from UTC to the current time zone for retrieval. (This does not occur for other types such as DATETIME.) By default, the current time zone for each connection is the server's time. The time zone can be set on a per-connection basis. As long as the time zone setting remains constant, you get back the same value you store. If you store a TIMESTAMP value, and then change the time zone and retrieve the value, the retrieved value is different from the value you stored. This occurs because the same time zone was not used for conversion in both directions. The current time zone is available as the value of the time_zone system variable. For more information, see Section 10.6, “MySQL Server Time Zone Support”.

The TIMESTAMP data type offers automatic initialization and updating to the current date and time. For more information, see Section 11.3.5, “Automatic Initialization and Updating for TIMESTAMP”.

A DATETIME or TIMESTAMP value can include a trailing fractional seconds part in up to microseconds (6 digits) precision. Although this fractional part is recognized, it is discarded from values stored into DATETIME or TIMESTAMP columns. For information about fractional seconds support in MySQL, see Section 11.3.6, “Fractional Seconds in Time Values”.

Illegal DATE, DATETIME, or TIMESTAMP values are converted to the “zero” value of the appropriate type ('0000-00-00' or '0000-00-00 00:00:00').

Be aware of certain properties of date value interpretation in MySQL:

    MySQL permits a “relaxed” format for values specified as strings, in which any punctuation character may be used as the delimiter between date parts or time parts. In some cases, this syntax can be deceiving. For example, a value such as '10:11:12' might look like a time value because of the “:” delimiter, but is interpreted as the year '2010-11-12' if used in a date context. The value '10:45:15' is converted to '0000-00-00' because '45' is not a legal month.

    As of 5.0.2, the server requires that month and day values be legal, and not merely in the range 1 to 12 and 1 to 31, respectively. With strict mode disabled, invalid dates such as '2004-04-31' are converted to '0000-00-00' and a warning is generated. With strict mode enabled, invalid dates generate an error. To permit such dates, enable ALLOW_INVALID_DATES. See Section 5.1.7, “Server SQL Modes”, for more information.

    Before MySQL 5.0.2, the MySQL server performs only basic checking on the validity of a date: The ranges for year, month, and day are 1000 to 9999, 00 to 12, and 00 to 31, respectively. Any date containing parts not within these ranges is subject to conversion to '0000-00-00'. Please note that this still permits you to store invalid dates such as '2002-04-31'. To ensure that a date is valid, you should perform a check in your application.

    As of MySQL 5.0.2, MySQL does not accept TIMESTAMP values that include a zero in the day or month column or values that are not a valid date. The sole exception to this rule is the special “zero” value '0000-00-00 00:00:00'.

    In MySQL 5.0, CAST() treats a TIMESTAMP value as a string when not selecting from a table. (This is true even if you specify FROM DUAL.) See Section 12.10, “Cast Functions and Operators”.

    Dates containing two-digit year values are ambiguous because the century is unknown. MySQL interprets two-digit year values using these rules:

        Year values in the range 00-69 are converted to 2000-2069.

        Year values in the range 70-99 are converted to 1970-1999. 

    See also Section 11.3.8, “Two-Digit Years in Dates”. 

Note

The MySQL server can be run with the MAXDB SQL mode enabled. In this case, TIMESTAMP is identical with DATETIME. If this mode is enabled at the time that a table is created, TIMESTAMP columns are created as DATETIME columns. As a result, such columns use DATETIME display format, have the same range of values, and there is no automatic initialization or updating to the current date and time. See Section 5.1.7, “Server SQL Modes”.
, %e (D 형식의 날짜), %m (MM 형식의 날짜), %c (M 형식의 날짜), , %k (H 형식의 시간, 24시간 형식), %h (HH 형식의 시간, 12시간 형식), , %p (AM 또는 PM) 


